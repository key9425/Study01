// 원시타입 vs 객체타입
// 구분하는 이유: 값이 저장되거나 복사되는 과정이 서로 다르기 때문

// 원시 타입
// - 값 자체로써 변수에 저장되고 복사된다
// - 불변값 (메모리 값 수정 X - 실제 메모리 공간에 저정된 원본 데이터 값은 수정되지 않음)
let p1 = 1;
let p2 = p1;
p2 = 2;

// 객체 타입
// - 참조값을 통해 변수에 저장되고 복사된다
// - 가변값 (메모리 값 수정 O)
let o1 = { name: "이정환" };
let o2 = o1;
o2.name = "홍길동";

// ---------------------------------------------------------------------------
// 객체 타입 주의사항 1. 의도치 않게 값이 수정될 수 있다
// - Side Effect : 의도하지 않았는데 하나의 변화가 또 다른 변수의 변화를 가져오는 것

// 1-1. 얕은 복사 : 객체의 참조값을 복사함
// - 원본 객체가 수정될 수 있어 위험함
let o1_1 = { name: "이정환" };
let o2_1 = o1_1;

// 1-2. 깊은 복사 : 새로운 객체를 생성하면서 프로퍼티만 따로 복사함
// - 원본 객체가 수정될 일이 없어 안전함
let o3_1 = { name: "이정환" };
let o4_1 = { ...o3_1 };

// ---------------------------------------------------------------------------
// 객체 타입 주의사항 2. 객체간의 비교는 기본적으로 참조값을 기준으로 이루어진다
let o1_2 = { name: "이정환" };
let o2_2 = o1_2;
let o3_2 = { ...o1_2 };

// 2-1. 얕은 비교 : 참조값을 기준으로 비교
o1_2 === o2_2; // True
o1_2 === o3_2; // False, 참조값이 서로 다른 두 객체이기 때문에

// 2-2. 깊은 비교 : 객체를 문자열로 변환하여 참조값이 아닌 프로퍼티의 값을 기준으로 비교
// - JSON.stringify 등의 내장 함수를 이용해야 함
JSON.stringify(o1_2) === JSON.stringify(o3_2); // True

// ---------------------------------------------------------------------------
// 객체 타입 주의사항 3. 배열과 함수도 사실 객체이다
// - 객체에 존재하는 프로퍼티와 메서드를 가지고(가질수) 있음
